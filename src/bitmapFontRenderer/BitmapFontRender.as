package bitmapFontRenderer {
import flash.display.BitmapData;
import flash.geom.Matrix;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.Dictionary;

/**
 * Tool to drawn bitmap font to a BitmapData.
 *
 * Uses BitmapFont data as generated by :
 *  - BMFont (http://www.angelcode.com/products/bmfont/, win32)
 *  - Hiero (http://slick.cokeandcode.com/demos/hiero.jnlp, cross platform)
 *  - Littera (http://kvazars.com/littera/, web)
 *
 * Currently does not support:
 *      - Kerning.
 *      - Channel packing (currently blits all channels).
 *      - Line breaks/text alignment.
 *      - Unicode outside of the Basic Multilingual Plane.
 */
public class BitmapFontRender {

	public static const LEFT:String = "left";
	public static const CENTER:String = "center";
	public static const RIGHT:String = "right";

	private static var glyphMap:Dictionary = new Dictionary();
	private static var glyphLineHeight:Dictionary = new Dictionary();
	private static var sheets:Dictionary = new Dictionary();

	private static var defaultFont:String;

	private static var newLineNChar:int;
	private static var newLineRChar:int;

	//---------------------------------
	//
	//---------------------------------

	/**
	 * Draw a string to creates new or provided BitmapData, and returns it.
	 * @param text            text to show
	 * @param target        optional bitmap data to draw text on.
	 * @param fontName        optional font name used with addFont() function.
	 * @param offsetX      print font with x offset.
	 * @param offsetY     print font with y offset.
	 * @param textAlign      alignment of text in rectangle, BitmapFont.LEFT, BitmapFont.CENTER or BitmapFont.RIGHT.
	 * @param minWidth     optional force minimal width for text rectangle. if <1 - minimal width to fit the font will be used.
	 * @param minHeight      optional force minimal height for text rectangle. if <1 - minimal width to fit the font will be used.
	 * @param maxWidth     optional force maximum width for text rectangle. if <1 - it will be as big as needed to fit all text.
	 * @param maxHeight      optional force maximum height for text rectangle. if <1 - it will be as big as needed to fit all text.
	 * @return      returns bitmap data with printed text.
	 */
	public static function renderText(text:String, fontName:String = null, target:BitmapData = null, offsetX:int = 0, offsetY:int = 0, textAlign:String = "left", minWidth:int = 0, minHeight:int = 0, maxWidth:int = 0, maxHeight:int = 0):BitmapData {
		if (!fontName) {
			fontName = defaultFont;
		}
		var blockVo:BitmapBlockVO = getTextSize(text, fontName);
		if (target == null) {
			var bitmapWidth:int = blockVo.width;
			var bitmapHeight:int = blockVo.height;
			// handle min/max size
			if (maxWidth > 0) {
				if (bitmapWidth > maxWidth) {
					bitmapWidth = maxWidth;
				}
			}
			if (minWidth > 0) {
				if (bitmapWidth < minWidth) {
					bitmapWidth = minWidth;
				}
			}
			if (maxHeight > 0) {
				if (bitmapHeight > maxHeight) {
					bitmapHeight = maxHeight;
				}
			}
			if (minHeight > 0) {
				if (bitmapHeight < minHeight) {
					bitmapHeight = minHeight;
				}
			}
			if (bitmapWidth < 1) {
				bitmapWidth = 1;
			}
			if (bitmapHeight < 1) {
				bitmapHeight = 1;
			}
			target = new BitmapData(bitmapWidth, bitmapHeight, true, 0xFF);
		}
		if (minWidth > 0) {
			if (blockVo.width < minWidth) {
				blockVo.width = minWidth;
			}
		}
		var fontMap:Array = glyphMap[fontName];
		var fontPics:Array = sheets[fontName];
		if (fontMap && fontPics) {
			var lineNr:int = 0;
			var curX:int = offsetX;
			var curY:int = offsetY;
			if (blockVo.lineWidth.length > lineNr) {
				if (textAlign == BitmapFontRender.CENTER) {
					curX += blockVo.width / 2 - blockVo.lineWidth[lineNr] / 2;
				}
				if (textAlign == BitmapFontRender.RIGHT) {
					curX += blockVo.width - blockVo.lineWidth[lineNr];
				}
			}
			var sourceRectangle:Rectangle = new Rectangle();
			var destinationPoint:Point = new Point();
			// Walk the string.
			for (var curCharIdx:int = 0; curCharIdx < text.length; curCharIdx++) {
				// Identify the glyph.
				var curChar:int = text.charCodeAt(curCharIdx);
				if (curChar == newLineNChar || curChar == newLineRChar) {
					// skip double new line chars.
					if (curChar == newLineNChar && curCharIdx < text.length - 1) {
						curChar = text.charCodeAt(curCharIdx + 1);
						if (curChar == newLineRChar) {
							curCharIdx += 1;
						}
					}
					if (curChar == newLineRChar && curCharIdx < text.length - 1) {
						curChar = text.charCodeAt(curCharIdx + 1);
						if (curChar == newLineNChar) {
							curCharIdx += 1;
						}
					}
					curX = offsetX;
					curY += glyphLineHeight[fontName];
					lineNr++;
					if (blockVo.lineWidth.length > lineNr) {
						if (textAlign == BitmapFontRender.CENTER) {
							curX += blockVo.width / 2 - blockVo.lineWidth[lineNr] / 2;
						}
						if (textAlign == BitmapFontRender.RIGHT) {
							curX += blockVo.width - blockVo.lineWidth[lineNr];
						}
					}
				} else {
					var curGlyph:BitmapGlyph = fontMap[curChar];
					if (curGlyph) {
						var sourceBd:BitmapData = fontPics[curGlyph.page];
						// skip missing glyphs.
						if (sourceBd) {
							// set draw parameters
							sourceRectangle.x = curGlyph.x;
							sourceRectangle.y = curGlyph.y;
							sourceRectangle.width = curGlyph.width;
							sourceRectangle.height = curGlyph.height;
							destinationPoint.x = curX + curGlyph.xoffset;
							destinationPoint.y = curY + curGlyph.yoffset;
							// Draw the glyph.
							target.copyPixels(sourceBd, sourceRectangle, destinationPoint, null, null, true);
							// Update cursor position
							curX += curGlyph.xadvance;
						}
					}
				}
			}
		}
		return target;
	}

	public static function getTextSize(text:String, fontName:String = null):BitmapBlockVO {
		var retVal:BitmapBlockVO = new BitmapBlockVO();
		if (!fontName) {
			fontName = defaultFont;
		}
		var fontMap:Array = glyphMap[fontName];
		var fontPics:Array = sheets[fontName];
		if (fontMap && fontPics) {
			var curX:int = 0;
			var curY:int = 0;
			var nextX:int = 0;
			var nextY:int = 0;
			var lineWidth:int = 0;
			// Walk the string.
			for (var curCharIdx:int = 0; curCharIdx < text.length; curCharIdx++) {
				// Identify the glyph.
				var curChar:int = text.charCodeAt(curCharIdx);
				if (curChar == newLineNChar || curChar == newLineRChar) {
					// skip double new line chars.
					if (curChar == newLineNChar && curCharIdx < text.length - 1) {
						curChar = text.charCodeAt(curCharIdx + 1);
						if (curChar == newLineRChar) {
							curCharIdx += 1;
						}
					}
					if (curChar == newLineRChar && curCharIdx < text.length - 1) {
						curChar = text.charCodeAt(curCharIdx + 1);
						if (curChar == newLineNChar) {
							curCharIdx += 1;
						}
					}
					retVal.lineWidth.push(lineWidth);
					curX = 0;
					curY += glyphLineHeight[fontName];
				} else {
					var curGlyph:BitmapGlyph = fontMap[curChar];
					if (curGlyph) {
						var sourceBd:BitmapData = fontPics[curGlyph.page];
						// skip missing glyphs.
						if (sourceBd) {
							// Update cursor position
							nextX = curX + curGlyph.xoffset + curGlyph.width;
							nextY = curY + curGlyph.yoffset + curGlyph.height;
							curX += curGlyph.xadvance;
							if (curX > nextX) {
								lineWidth = curX;
							} else {
								lineWidth = nextX;
							}
							if (retVal.width < lineWidth) {
								retVal.width = lineWidth;
							}
							if (retVal.height < nextY) {
								retVal.height = nextY;
							}
						}
					}
				}
			}
		}
		retVal.lineWidth.push(lineWidth);
		return retVal;
	}

	//---------------------------------
	// set up
	//---------------------------------

	public static function addFont(fontName:String, fontDesc:String, pagePics:Array, isFlipped:Boolean = false, useAsDefault:Boolean = false):void {
		parseFont(fontName, fontDesc);
		for (var i:int = 0; i < pagePics.length; i++) {
			var pageBD:BitmapData = pagePics[i];
			addSheet(fontName, i, pageBD, isFlipped);
		}
		if (useAsDefault || !defaultFont) {
			defaultFont = fontName;
		}
		newLineNChar = String("\n").charCodeAt(0);
		newLineRChar = String("\r").charCodeAt(0);
	}

	/**
	 * Add a bitmap sheet.
	 */
	private static function addSheet(fontName:String, id:int, bits:BitmapData, isFlipped:Boolean = false):void {
		if (!sheets[fontName]) {
			sheets[fontName] = new Array();
		}
		if (sheets[fontName][id] != null) {
			throw new Error("Overwriting sheet!");
		}
		if (isFlipped) {
			sheets[fontName][id] = flipVert(bits);
		} else {
			sheets[fontName][id] = bits;
		}
	}

	/**
	 * Parse a BMFont textual font description.
	 */
	private static function parseFont(fontName:String, fontDesc:String):void {
		if (!glyphMap[fontName]) {
			glyphMap[fontName] = new Array();
		}
		var fontLines:Array = fontDesc.split("\n");
		for (var i:int = 0; i < fontLines.length; i++) {
			// Lines can be one of:  info,  page,  chars,  char,  common
			var fontLine:Array = (fontLines[i] as String).split(" ");
			var keyWord:String = (fontLine[0] as String).toLowerCase();
			if (keyWord == "char") {
				parseChar(fontName, fontLine);
			} else if (keyWord == "common") {
				parseLineHeight(fontName, fontLine);
			}
		}
	}

	/**
	 * Helper function to parse and register a glyph from a BMFont
	 * description..
	 */
	private static function parseChar(fontName:String, charLine:Array):void {
		var g:BitmapGlyph = new BitmapGlyph();
		for (var i:int = 1; i < charLine.length; i++) {
			// Parse to key value.
			var charEntry:Array = (charLine[i] as String).split("=");
			if (charEntry.length == 2) {
				var charKey:String = charEntry[0];
				var charVal:String = charEntry[1];

				// Assign to glyph.
				if (g.hasOwnProperty(charKey)) {
					g[charKey] = charVal;
				}
			}
		}
		glyphMap[fontName][g.id] = g;
	}

	private static function parseLineHeight(fontName:String, commonLine:Array):void {
		glyphLineHeight[fontName] = 0;
		for (var i:int = 1; i < commonLine.length; i++) {
			// Parse to key value.
			var charEntry:Array = (commonLine[i] as String).split("=");
			if (charEntry.length == 2) {
				var charKey:String = charEntry[0];
				if (charKey == "lineHeight") {
					glyphLineHeight[fontName] = int(charEntry[1]);
				}
			}
		}
	}


	//---------------------------------
	// utils
	//---------------------------------

	/**
	 * Utility function to return a copy of a BitmapData flipped vertically.
	 */
	public static function flipVert(bd:BitmapData):BitmapData {
		var mat:Matrix = new Matrix();
		mat.d = -1;
		mat.ty = bd.height;
		var flip:BitmapData = new BitmapData(bd.width, bd.height, bd.transparent, 0x0);
		flip.draw(bd, mat);
		return flip;
	}

}
}